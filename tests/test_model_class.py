import os
import time
import unittest

import numpy as np

from ai4water import Model
from ai4water.datasets import arg_beach
from ai4water.utils.utils import find_best_weight
from ai4water.functional import Model as FModel
from ai4water.pre_processing.datahandler import DataHandler


dh = DataHandler(data=arg_beach(), verbosity=0)
x, y = dh.training_data()

mlp_model = {"layers": {"Dense": 8, "Dense_1": 1}}


def test_user_defined_data(_model):
    # using user defined x
    t,p = _model.predict(x=x, return_true=True)
    assert t is None
    assert len(p) == len(x)

    # using user defined x and y, post_processing must happen
    t,p = _model.predict(x=x, y=y, return_true=True)
    assert len(t) == len(p) == len(y)

    return


def _test_ml_inbuilt_data(_model):
    model = _model(model="RandomForestRegressor",
                  data=arg_beach(),
                  verbosity=0)
    model.fit()

    test_user_defined_data(model)

    t,p = model.predict(return_true=True)
    assert len(t) == len(p)
    return

def _test_ml_userdefined_data(_model):
    model = _model(model="RandomForestRegressor", verbosity=0)
    model.fit(x=x, y=y)

    test_user_defined_data(model)

    return model

def _test_fit(_model):
    model = _model(model="RandomForestRegressor", verbosity=0)
    model.fit(x,y)

    model.fit(x, y=y)

    model.fit(x=x, y=y)
    return


def _test_ml_userdefined_non_kw(_model):
    # using non-keyword arguments to .predict
    model = _model(model="RandomForestRegressor", verbosity=0)
    model.fit(x=x, y=y)

    model.predict(x)
    return

def _test_hydro_metrics(_model):
    model = _model(model="RandomForestRegressor", verbosity=0)
    model.fit(x=x, y=y)

    for metrics in ["minimal", "hydro_metrics", "all"]:
        model.predict(x=x, metrics=metrics)
    return


def _test_from_config_basic(_model, find_best=False):

    for m in ["RandomForestRegressor",
              "XGBoostRegressor",
              "CatBoostRegressor",
              "LGBMRegressor",
              mlp_model
              ]:
        model = _model(model=m, data=arg_beach(), lookback=1, verbosity=0)
        model.fit(x,y)
        ini_y = model.predict(np.arange(13).reshape(-1,13)).item()

        m2 = Model.from_config(os.path.join(model.path, 'config.json'))

        best_weight = None
        if find_best:
            best_weight = os.path.join(model.w_path, find_best_weight(model.w_path))

        m2.update_weights(best_weight)
        fin_y = m2.predict(np.arange(13).reshape(-1,13)).item()
        assert np.allclose(ini_y, fin_y)
        time.sleep(1)

    return


class TestPredictMethod(unittest.TestCase):

    def test_ml_inbuilt_data(self):
        _test_ml_inbuilt_data(Model)
        return

    def test_ml_inbuilt_data_fn(self):
        _test_ml_inbuilt_data(FModel)
        return

    def test_ml_userdefined_data(self):
        model = _test_ml_userdefined_data(Model)
        # using data generated by DataHnadler
        self.assertRaises(ValueError, model.predict)
        return

    def test_ml_userdefined_data_fn(self):
        model = _test_ml_userdefined_data(FModel)
        # using data generated by DataHnadler
        self.assertRaises(ValueError, model.predict)
        return

    def test_ml_userdefined_non_kw(self):
        _test_ml_userdefined_non_kw(Model)
        return

    def test_ml_userdefined_non_kw_fn(self):
        _test_ml_userdefined_non_kw(FModel)
        return

    def test_hydro_metrics(self):
        _test_hydro_metrics(Model)
        return

    def test_hydro_metrics_functional(self):
        _test_hydro_metrics(FModel)
        return


class TestFit(unittest.TestCase):

    def test_fit(self):
        _test_fit(Model)
        return

    def test_fit_functional(self):
        _test_fit(FModel)
        return


class TestFromConfig(unittest.TestCase):

    def test_basic_subclassing(self):
        _test_from_config_basic(Model)

    def test_basic_subclassing_fn(self):
        _test_from_config_basic(FModel)

    def test_basic_subclassing_with_weiths(self):
        _test_from_config_basic(Model, find_best=True)

    def test_basic_subclassing_fn_with_weights(self):
        _test_from_config_basic(FModel, find_best=True)


if __name__ == "__main__":

    unittest.main()