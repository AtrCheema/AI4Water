import os
import time
import unittest

import numpy as np
import tensorflow as tf

if 230 <= int(''.join(tf.__version__.split('.')[0:2]).ljust(3, '0')) < 250:
    from ai4water.functional import Model
    print(f"Switching to functional API due to tensorflow version {tf.__version__}")
else:
    from ai4water import Model

from ai4water.datasets import arg_beach
from ai4water.utils.utils import find_best_weight
from ai4water.functional import Model as FModel
from ai4water.preprocessing.datahandler import DataHandler
from ai4water._optimize import make_space


data = arg_beach()
dh = DataHandler(data=data, verbosity=0)
x, y = dh.training_data()

mlp_model = {"layers": {"Dense": 8, "Dense_1": 1}}


def test_user_defined_data(_model):
    # using user defined x
    t,p = _model.predict(x=x, return_true=True)
    assert t is None
    assert len(p) == len(x)

    # using user defined x and y, post_processing must happen
    t,p = _model.predict(x=x, y=y, return_true=True)
    assert len(t) == len(p) == len(y)

    return


def _test_ml_inbuilt_data(_model):
    model = _model(model="RandomForestRegressor",
                  data=arg_beach(),
                  verbosity=0)
    model.fit()

    test_user_defined_data(model)

    t,p = model.predict(return_true=True)
    assert len(t) == len(p)
    return

def _test_ml_userdefined_data(_model):
    model = _model(model="RandomForestRegressor", verbosity=0)
    model.fit(x=x, y=y)

    test_user_defined_data(model)

    return model

def _test_fit(_model):
    model = _model(model="RandomForestRegressor", verbosity=0)
    model.fit(x,y)

    model.fit(x, y=y)

    model.fit(x=x, y=y)
    return


def _test_ml_userdefined_non_kw(_model):
    # using non-keyword arguments to .predict
    model = _model(model="RandomForestRegressor", verbosity=0)
    model.fit(x=x, y=y)

    model.predict(x)
    return

def _test_hydro_metrics(_model):
    model = _model(model="RandomForestRegressor", verbosity=0)
    model.fit(x=x, y=y)

    for metrics in ["minimal", "hydro_metrics", "all"]:
        model.predict(x=x, metrics=metrics)
    return


def _test_from_config_basic(_model, find_best=False, config_file=False):

    for m in ["RandomForestRegressor",
              "XGBoostRegressor",
              "CatBoostRegressor",
              "LGBMRegressor",
              mlp_model
              ]:
        model = _model(model=m, data=arg_beach(), lookback=1, verbosity=0)
        model.fit(x,y)
        ini_y = model.predict(np.arange(13).reshape(-1,13)).item()

        if config_file:
            m2 = Model.from_config_file(os.path.join(model.path, 'config.json'))
        else:
            m2 = Model.from_config(model.config)

        best_weight = None
        if find_best:
            best_weight = os.path.join(model.w_path, find_best_weight(model.w_path))

        m2.update_weights(best_weight)
        fin_y = m2.predict(np.arange(13).reshape(-1,13)).item()
        assert np.allclose(ini_y, fin_y)
        time.sleep(1)

    return


class TestPredictMethod(unittest.TestCase):

    def test_ml_inbuilt_data(self):
        _test_ml_inbuilt_data(Model)
        return

    def test_ml_inbuilt_data_fn(self):
        _test_ml_inbuilt_data(FModel)
        return

    def test_ml_userdefined_data(self):
        model = _test_ml_userdefined_data(Model)
        # using data generated by DataHnadler
        self.assertRaises(ValueError, model.predict)
        return

    def test_ml_userdefined_data_fn(self):
        model = _test_ml_userdefined_data(FModel)
        # using data generated by DataHnadler
        self.assertRaises(ValueError, model.predict)
        return

    def test_ml_userdefined_non_kw(self):
        _test_ml_userdefined_non_kw(Model)
        return

    def test_ml_userdefined_non_kw_fn(self):
        _test_ml_userdefined_non_kw(FModel)
        return

    def test_hydro_metrics(self):
        _test_hydro_metrics(Model)
        return

    def test_hydro_metrics_functional(self):
        _test_hydro_metrics(FModel)
        return


class TestFit(unittest.TestCase):

    def test_fit(self):
        _test_fit(Model)
        return

    def test_fit_functional(self):
        _test_fit(FModel)
        return


class TestFromConfig(unittest.TestCase):

    def test_subclassing(self):
        _test_from_config_basic(Model)
        return

    def test_subclassing_fn(self):
        _test_from_config_basic(FModel)

    def test_subclassing_with_weights(self):
        _test_from_config_basic(Model, find_best=True)

    def test_subclassing_fn_with_weights(self):
        # we are able to load functinoal model
        _test_from_config_basic(FModel, find_best=True)

    def test_subclassing_with_config_file(self):
        # we are able to load subclassing Model from config_file
        _test_from_config_basic(Model, config_file=True)
        return

    def test_fn_with_config_file(self):
        # we are able to load functional model from config_file
        _test_from_config_basic(FModel, config_file=True)
        return


class TestOptimize(unittest.TestCase):

    def test_optimize_transformations(self):

        df = arg_beach(inputs=["tide_cm", "wat_temp_c", "rel_hum"])

        model = FModel(model="xgboostregressor", data=df)

        model.optimize_transformations(exclude="tide_cm", algorithm="random", num_iterations=3)
        assert isinstance(model.config['transformation'], list)
        return

    def test_make_space(self):
        space = make_space(data.columns.to_list(), categories=['log', 'log2', 'minmax', 'none'])
        assert len(space) == 14
        # include
        space = make_space(data.columns.to_list(), include="tide_cm",
                           categories=['log', 'log2', 'minmax', 'none'])
        assert len(space) == 1

        include = ["tide_cm", "tetx_coppml"]
        space = make_space(data.columns.to_list(), include=include,
                           categories=['log', 'log2', 'minmax', 'none'])
        for sp, _name in zip(space, include):
            assert sp.name == _name

        exclude = "tide_cm"
        space = make_space(data.columns.to_list(), exclude=exclude,
                           categories=['log', 'log2', 'minmax', 'none'])
        for sp in space:
            assert sp.name != exclude

        exclude = ["tide_cm", "tetx_coppml"]
        space = make_space(data.columns.to_list(), exclude=exclude,
                           categories=['log', 'log2', 'minmax', 'none'])
        for sp in space:
            assert sp.name not in exclude

        new = {"tetx_coppml": ["log", "log2", "log10"]}
        space = make_space(data.columns.to_list(), include="tetx_coppml", append=new,
                           categories=['log', 'log2', 'minmax', 'none', 'log10'])
        assert len(space) == 1, space
        assert len(space[0].categories) == 3
        return


if __name__ == "__main__":

    unittest.main()